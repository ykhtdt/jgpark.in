---
status: 'published'
title: 'Feature Sliced Design: 프론트엔드 아키텍처 방법론'
description: '기존 아키텍처의 문제점과 Feature Sliced Design의 해결책, 그리고 실무에서의 점진적 적용 방법'
publishedAt: '2025-06-08T11:00:00.000Z'
author:
  name: 'jgpark'
  picture: 'https://avatars.githubusercontent.com/u/150231680?v=4'
slug: 'feature-sliced-design-advantages'
---

## Feature Sliced Design 아키텍처의 장점

최근 프론트엔드 애플리케이션의 복잡성이 급증하면서, 확장 가능하고 유지보수하기 쉬운 코드베이스를 구성하는 것이 더욱 중요해졌습니다.
이러한 배경에서 Feature Sliced Design(FSD)은 프론트엔드 아키텍처에 대한 체계적인 접근 방식을 제시합니다.
이 글에서는 기존 아키텍처의 문제점, FSD가 이를 어떻게 해결하는지, 그리고 실무에서 FSD를 점진적으로 도입하는 방법에 대해 알아보겠습니다.

## 기존 프론트엔드 아키텍처의 한계점

기존의 프론트엔드 아키텍처 방식들은 다음과 같은 한계점을 가지고 있었습니다:

### 1. 기술 중심 구조

```markdown
project/
├── components/
├── services/
├── hooks/
├── lib/
├── utils/
├── styles/
└── types/
```

이러한 기술 중심 구조는 초기에는 이해하기 쉽지만, 애플리케이션이 성장함에 따라 여러 문제점이 발생합니다:

- **컴포넌트 폴더의 비대화**: 모든 UI 컴포넌트가 단일 'components' 폴더에 모이면서 수백 개의 파일을 관리해야 하는 상황이 발생합니다. 예를 들어, Button, Modal, Card 같은 기본 컴포넌트부터 LoginForm, ProductDetails, CheckoutSummary 같은 복잡한 컴포넌트까지 모두 한 폴더에 있으면 필요한 컴포넌트를 찾기 어렵고 관리하기 힘듭니다.

- **관련 코드 분산**: 하나의 기능에 관련된 코드가 여러 폴더에 분산되어 있어 기능 이해와 수정이 어렵습니다. 예를 들어, 사용자 인증 기능을 구현하려면 'components/LoginForm.tsx', 'services/authService.ts', 'hooks/useAuth.ts', 'utils/validators.ts' 등 여러 파일을 찾아다녀야 합니다. 이렇게 관련 코드가 분산되어 있으면 기능 전체를 파악하기 어려워집니다.

- **의존성 관리 어려움**: 명확한 의존성 규칙이 없어 순환 참조 등의 문제가 발생하기 쉽습니다. 예를 들어, 'hooks' 폴더의 코드가 'services' 폴더를 참조하고, 'services'가 다시 'hooks'를 참조하는 순환 의존성이 생길 수 있으며, 이는 코드의 예측 가능성과 테스트 용이성을 저하시킵니다.

### 2. 도메인 중심 구조

```markdown
project/
├── user/
│   ├── components/
│   ├── services/
│   └── hooks/
└── product/
    ├── components/
    ├── services/
    └── hooks/
```

도메인 중심 구조는 기술 중심 구조의 일부 문제를 해결하지만, 여전히 다음과 같은 한계가 있습니다:

- **책임 구분의 모호함**: 도메인별로 코드를 분리했지만, 각 모듈의 책임 수준이 명확하지 않습니다. 예를 들어, 'user' 도메인 내에서 단순 데이터 모델(UserModel)과 복잡한 비즈니스 로직(UserAuthentication), 그리고 UI 컴포넌트(UserProfile)의 구분이 명확하지 않습니다. 결과적으로, 'user' 폴더가 너무 많은 책임을 가지게 되거나, 다른 도메인과의 책임 경계가 모호해집니다.

- **재사용성 저하**: 도메인 간에 공유가 필요한 코드의 재사용 메커니즘이 부족합니다. 예를 들어, 'user'와 'product' 도메인 모두에서 필요한 날짜 포맷팅 유틸리티나 공통 UI 컴포넌트를 어디에 두어야 할지 명확하지 않습니다. 'common' 폴더를 만들더라도, 어떤 코드가 공통으로 분류되어야 하는지에 대한 기준이 모호해 일관성 없는 코드 구성이 발생합니다.

- **의존성 방향 불명확**: 모듈 간 의존성 방향에 대한 명확한 규칙이 없어 아키텍처가 무너지기 쉽습니다. 예를 들어, 사용자가 제품에 리뷰를 남기는 기능을 구현할 때, 이 코드가 'user' 도메인에 속하는지 'product' 도메인에 속하는지 모호합니다. 이로 인해 두 도메인 간에 순환 참조가 발생하거나, 한 도메인이 다른 도메인에 과도하게 의존하게 될 수 있습니다. 장기적으로 이는 코드베이스 전체의 유지보수성을 저하시킵니다.

## Feature Sliced Design의 문제 해결 접근법

FSD는 위에서 언급한 기존 아키텍처의 문제점을 다음과 같이 해결합니다:

### 1. 명확한 책임 계층 구조

FSD는 6개의 레이어(App, Pages, Widgets, Features, Entities, Shared)로 구성되며, 각 레이어는 명확한 책임 수준을 가집니다:

```markdown
project/
├── app/        // 애플리케이션 초기화 및 전역 설정
├── pages/      // 라우팅 가능한 화면
├── widgets/    // 독립적인 UI 블록
├── features/   // 사용자 상호작용 및 비즈니스 기능
├── entities/   // 비즈니스 엔티티 및 관련 UI 컴포넌트
└── shared/     // 공유 유틸리티 및 UI 키트
```

**기존 문제 해결**: 
- **"컴포넌트 폴더의 비대화" 문제 해결**: 컴포넌트를 책임에 따라 여러 레이어로 분산시킵니다. 예를 들어, 기본 버튼은 `shared/ui`에, 인증 폼은 `features/auth`에, 헤더는 `widgets/header`에 위치시켜 컴포넌트의 목적과 책임에 따라 구분합니다.
  
- **"관련 코드 분산" 문제 해결**: 각 슬라이스 내에서 관련 코드를 함께 위치시킵니다. 예를 들어, 인증 기능에 관련된 UI 컴포넌트, API 호출, 상태 관리 코드를 모두 `features/auth` 슬라이스 내에 배치하여 관련 코드를 쉽게 찾고 이해할 수 있게 합니다.
  
- **"책임 구분의 모호함" 문제 해결**: 각 레이어에 명확한 책임을 부여합니다. 예를 들어:
  - `app`: 애플리케이션 초기화, 전역 설정, 라우터 구성, 프로바이더 설정
  - `pages`: 라우팅 가능한 페이지 컴포넌트
  - `widgets`: 여러 페이지에서 재사용 가능한 큰 UI 블록
  - `features`: 사용자 상호작용 및 비즈니스 기능
  - `entities`: 비즈니스 엔티티의 데이터 모델 및 기본 UI 컴포넌트
  - `shared`: 비즈니스 도메인에 의존하지 않는 공통 유틸리티 및 UI 키트

### 2. 명확한 의존성 규칙

FSD는 레이어 간 명확한 의존성 규칙을 제공합니다:

- **하향식 의존성만 허용**: 상위 레이어는 하위 레이어에만 의존할 수 있습니다. 예를 들어, `features` 레이어는 `entities`와 `shared`에만 의존할 수 있고, `widgets`나 `pages`에는 의존할 수 없습니다.
  
- **수평적 의존성 금지**: 동일한 레이어 내 다른 슬라이스에 직접 의존할 수 없습니다. 예를 들어, `features/auth`는 `features/comments`에서 직접 가져올 수 없습니다. 두 슬라이스 간에 공유가 필요한 코드는 더 낮은 레이어(`entities` 또는 `shared`)로 이동해야 합니다.
  
- **교차 가져오기(@x) 예외**: 엔티티 간 관계가 필요한 특별한 경우, `@x` 표기법을 사용하여 제한된 교차 참조를 허용할 수 있습니다. 예를 들어, `entities/user/@x/product`는 "사용자 엔티티가 제품 엔티티와 교차하는 지점"을 나타냅니다.

**기존 문제 해결**: 
- **"의존성 관리 어려움"과 "의존성 방향 불명확" 문제 해결**: 명확한 의존성 규칙을 통해 코드 구조를 예측 가능하게 만들고, 의존성 방향을 명확히 합니다.
  
- **순환 참조 문제 방지**: 하향식 의존성만 허용함으로써 순환 참조를 원천적으로 방지합니다. 이는 코드의 테스트 용이성과 유지보수성을 크게 향상시킵니다.

### 3. 기능 중심 조직

FSD는 비즈니스 기능을 중심으로 코드를 조직화합니다:

```markdown
features/
├── auth/
│   ├── ui/      // 로그인 폼, 회원가입 폼 등
│   ├── model/   // 인증 상태 관리, 유효성 검사 등
│   ├── api/     // 인증 API 요청
│   ├── lib/     // 인증 관련 유틸리티
│   └── index.ts // Public API
└── product-search/
    ├── ui/      // 검색 폼, 필터 컴포넌트 등
    ├── model/   // 검색 상태 및 로직
    ├── api/     // 검색 API 요청
    ├── lib/     // 검색 관련 유틸리티
    └── index.ts // Public API
```

**기존 문제 해결**: 
- **"관련 코드 분산" 문제 해결**: 하나의 기능에 관련된 모든 코드(UI, API, 상태 관리, 유틸리티)를 동일한 슬라이스에 위치시켜 관련 코드를 쉽게 찾고 이해할 수 있게 합니다.
  
- **"재사용성 저하" 문제 해결**: 
  - 여러 기능에서 공유해야 하는 비즈니스 엔티티는 `entities` 레이어에 배치합니다.
  - 비즈니스 도메인에 종속되지 않은 공통 코드는 `shared` 레이어에 배치합니다.
  - 이를 통해 코드 중복을 방지하고 재사용성을 높입니다.

### 4. Public API를 통한 캡슐화

FSD는 각 슬라이스의 Public API를 통해 내부 구현을 캡슐화합니다:

```javascript
// features/auth/index.ts (Public API)
export { LoginForm } from './ui/LoginForm';
export { registerUser } from './model/registration';
// 내부 구현은 외부에 노출되지 않음
```

**기존 문제 해결**: 
- **모듈 내부 구현 보호**: 슬라이스 내부 구현 변경이 외부에 영향을 미치지 않도록 하여 유지보수성을 향상시킵니다. 외부 코드는 오직 Public API를 통해서만 슬라이스와 상호작용할 수 있습니다.
  
- **명확한 사용 계약 제공**: Public API는 슬라이스의 목적과 기능을 명확히 드러내어, 다른 개발자가 모듈의 사용법을 쉽게 이해할 수 있게 합니다.
  
- **와일드카드 재내보내기 지양**: `export * from './ui/Comment'`와 같은 와일드카드 재내보내기를 지양하고, 명시적으로 필요한 부분만 내보내어 모듈의 경계를 명확히 합니다.

### 5. 세그먼트를 통한 일관된 내부 구조

각 슬라이스는 일관된 세그먼트로 구성되어 코드 탐색과 이해를 용이하게 합니다:

- **ui**: 컴포넌트 및 시각적 요소
- **model**: 상태 관리 및 비즈니스 로직
- **api**: 외부 API와의 통신
- **lib**: 헬퍼 함수 및 유틸리티
- **config**: 구성 파일 및 설정

**기존 문제 해결**:
- **일관된 코드 구조**: 모든 슬라이스가 동일한 내부 구조를 따르므로, 개발자가 코드베이스의 어느 부분을 탐색하더라도 비슷한 구조를 기대할 수 있습니다.
  
- **책임 분리**: 각 세그먼트는 명확한 책임을 가지며, 이는 코드의 가독성과 유지보수성을 향상시킵니다.

이러한 FSD의 원칙들은 함께 작용하여 확장 가능하고, 유지보수하기 쉬우며, 예측 가능한 코드베이스를 구축하는 데 도움을 줍니다. 특히 팀 규모가 크거나 장기적인 프로젝트에서 그 효과가 두드러집니다.

## 실무에서의 FSD 점진적 도입 방법

FSD는 이상적인 아키텍처 패턴이지만, 실무에서는 기존 프로젝트에 한 번에 전체 구조를 적용하기 어려울 수 있습니다. 다음은 FSD를 점진적으로 도입하는 효과적인 방법입니다:

### 1. 기능 단위의 점진적 마이그레이션

모든 코드를 한 번에 FSD로 변환하려고 시도하지 마세요. 대신, 다음과 같이 진행하세요:

1. 새로운 기능부터 FSD 구조로 개발하기 시작합니다.
2. 기존 기능은 수정이 필요할 때 점진적으로 FSD 구조로 리팩토링합니다.
3. 우선순위가 낮은 레거시 코드는 당장 변경하지 않고 그대로 유지합니다.

### 2. 모든 레이어를 한 번에 도입할 필요 없음

FSD의 6개 레이어를 모두 한 번에 도입할 필요는 없습니다:

1. 초기에는 `pages`, `features`, `shared` 레이어만 사용하는 단순화된 버전으로 시작할 수 있습니다.
2. 애플리케이션이 성장함에 따라 필요한 경우 `widgets`, `entities` 레이어를 추가합니다.
3. `app` 레이어는 애플리케이션의 규모가 커질 때 도입을 고려합니다.

### 3. 레이어 내부 코드 배치의 유연성

실무에서는 항상 이상적인 코드 배치가 어려울 수 있습니다. FSD는 다음과 같은 유연성을 제공합니다:

1. **처음 사용되는 코드는 상위 레이어에 배치 가능**: 특정 기능이 한 페이지에서만 사용된다면, 처음에는 `pages` 레이어에 배치하고, 재사용이 필요해질 때 적절한 레이어(예: `features`)로 이동시킬 수 있습니다.

2. **점진적 추출**: 코드가 여러 곳에서 사용되기 시작하면, 그때 더 낮은 레이어로 추출하여 재사용성을 높입니다.

```markdown
pages/
├── product-page/
│   └── ProductReviews.tsx  // 처음에는 여기에 구현
└── profile-page/
    // 여기서도 리뷰 기능이 필요하다면?
    // → features/reviews로 추출하여 재사용
```

### 4. 실무 적용 팁

1. **팀의 합의**: FSD 도입 전에 팀원들과 충분히 논의하고 합의를 이끌어내세요.
2. **문서화**: 어떤 규칙을 따르고 있는지, 어떤 부분은 유연하게 적용할 것인지 문서화하세요.
3. **린터 설정**: 가능하다면 ESLint 등의 린터에 FSD 규칙을 설정하여 자동으로 의존성 규칙을 검사하세요.
4. **점진적 학습**: 팀원들이 FSD 개념을 점진적으로 학습할 수 있도록 시간을 주세요.

## 실제 적용 사례: 기존 코드와 FSD 코드의 비교

### 인증 기능 구현 비교

**기존 기술 중심 구조:**
```markdown
components/
├── LoginForm.tsx
└── RegisterForm.tsx
services/
└── authService.ts
hooks/
└── useAuth.ts
utils/
└── authValidators.ts
```

이 구조에서는 인증 관련 코드가 여러 폴더에 분산되어 있어, 인증 기능을 이해하거나 수정하기 위해 여러 파일을 찾아야 합니다.

**FSD 적용 후:**
```markdown
features/
└── auth/
    ├── ui/
    │   ├── LoginForm.tsx
    │   └── RegisterForm.tsx
    ├── api/
    │   └── authApi.ts
    ├── model/
    │   └── useAuth.ts
    ├── lib/
    │   └── validators.ts
    └── index.ts  // Public API
```

모든 인증 관련 코드가 한 곳에 모여 있어 관련 기능을 쉽게 찾고 이해할 수 있습니다.

### 점진적 도입 예시

프로젝트 초기에는 다음과 같이 단순화된 구조로 시작할 수 있습니다:

```markdown
pages/
├── home/
├── profile/
└── product/
features/
├── auth/
└── cart/
shared/
├── ui/
├── api/
└── lib/
```

애플리케이션이 성장함에 따라 필요한 레이어를 추가하고 코드를 적절한 위치로 리팩토링합니다:

```markdown
app/
pages/
widgets/
├── header/
├── footer/
└── product-card/
features/
entities/
├── user/
└── product/
shared/
```

## 결론

Feature Sliced Design은 프론트엔드 애플리케이션의 복잡성을 관리하기 위한 체계적인 접근 방식을 제공합니다. 기존 아키텍처의 한계를 극복하면서도, 실무에서 점진적으로 도입할 수 있는 유연성을 제공합니다.

FSD의 핵심 가치는 다음과 같습니다:

1. **명확한 책임 분리**로 코드 탐색과 이해가 용이해집니다.
2. **엄격한 의존성 규칙**으로 결합도를 낮추고 유지보수성을 향상시킵니다.
3. **기능 중심 조직**으로 비즈니스 도메인의 가시성을 높이고 개발 효율성을 증가시킵니다.
4. **점진적 도입 가능성**으로 실무에서 현실적으로 적용할 수 있습니다.

FSD는 처음부터 완벽하게 모든 레이어와 규칙을 적용할 필요가 없습니다. 프로젝트와 팀의 상황에 맞게 점진적으로 도입하면서, 필요에 따라 코드를 적절한 위치로 이동시키는 유연한 접근 방식이 실무에서 더 효과적입니다.

프론트엔드 아키텍처를 설계하거나 개선할 때 Feature Sliced Design의 원칙을 고려한다면, 더 유지보수하기 쉽고 확장 가능한 코드베이스를 구축할 수 있을 것입니다.
