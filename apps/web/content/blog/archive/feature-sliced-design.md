---
status: 'draft'
title: 'Feature Sliced Design: 프론트엔드 아키텍처 방법론'
description: '기존 아키텍처의 문제점과 Feature Sliced Design의 해결책, 그리고 실무에서의 점진적 적용 방법'
publishedAt: ''
author:
  name: 'jgpark'
  picture: 'https://avatars.githubusercontent.com/u/150231680?v=4'
slug: 'feature-sliced-design-advantages'
---

## Feature Sliced Design: 현대적 프론트엔드 아키텍처의 장점 {/* toc-title: 소개 */}

최근 프론트엔드 애플리케이션의 복잡성이 급증하면서, 확장 가능하고 유지보수하기 쉬운 코드베이스를 구성하는 것이 더욱 중요해졌습니다.
이러한 배경에서 Feature Sliced Design(FSD)은 프론트엔드 아키텍처에 대한 체계적인 접근 방식을 제시합니다.
이 글에서는 기존 아키텍처의 문제점, FSD가 이를 어떻게 해결하는지, 그리고 실무에서 FSD를 점진적으로 도입하는 방법에 대해 알아보겠습니다.

## 기존 프론트엔드 아키텍처의 한계점 {/* toc-title: 기존 아키텍처의 한계점 */}

기존의 프론트엔드 아키텍처 방식들은 다음과 같은 한계점을 가지고 있었습니다:

### 1. 기술 중심 구조

```markdown
project/
├── components/
├── services/
├── hooks/
├── lib/
├── utils/
├── styles/
└── types/
```

이러한 기술 중심 구조는 초기에는 이해하기 쉽지만, 애플리케이션이 성장함에 따라 여러 문제점이 발생합니다:

- **컴포넌트 폴더의 비대화**: 모든 컴포넌트가 한 폴더에 모이면서 수백 개의 파일을 관리해야 하는 상황이 발생합니다.
- **관련 코드 분산**: 하나의 기능에 관련된 코드가 여러 폴더에 분산되어 있어 기능 이해와 수정이 어렵습니다.
- **의존성 관리 어려움**: 명확한 의존성 규칙이 없어 순환 참조 등의 문제가 발생하기 쉽습니다.

### 2. 도메인 중심 구조

```markdown
project/
├── user/
│   ├── components/
│   ├── services/
│   └── hooks/
└── product/
    ├── components/
    ├── services/
    └── hooks/
```

도메인 중심 구조는 기술 중심 구조의 일부 문제를 해결하지만, 여전히 한계가 있습니다:

- **책임 구분의 모호함**: 도메인별로 코드를 분리했지만, 각 모듈의 책임 수준이 명확하지 않습니다.
- **재사용성 저하**: 도메인 간 공유가 필요한 코드의 재사용 메커니즘이 부족합니다.
- **의존성 방향 불명확**: 모듈 간 의존성 방향에 대한 명확한 규칙이 없어 아키텍처가 무너지기 쉽습니다.

## Feature Sliced Design의 문제 해결 접근법 {/* toc-title: FSD의 해결책 */}

FSD는 위에서 언급한 기존 아키텍처의 문제점을 다음과 같이 해결합니다:

### 1. 명확한 책임 계층 구조

FSD는 6개의 레이어(App, Pages, Widgets, Features, Entities, Shared)로 구성되며, 각 레이어는 명확한 책임 수준을 가집니다:

```markdown
project/
├── app/        // 애플리케이션 초기화 및 전역 설정
├── pages/      // 라우팅 가능한 화면
├── widgets/    // 독립적인 UI 블록
├── features/   // 사용자 상호작용 및 비즈니스 기능
├── entities/   // 비즈니스 엔티티 및 그 표현
└── shared/     // 공유 유틸리티 및 UI 키트
```

**기존 문제 해결**: 
- "컴포넌트 폴더의 비대화" 문제는 컴포넌트를 책임에 따라 여러 레이어로 분산시켜 해결합니다.
- "관련 코드 분산" 문제는 각 슬라이스 내에서 관련 코드를 함께 위치시켜 해결합니다.
- "책임 구분의 모호함" 문제는 각 레이어에 명확한 책임을 부여하여 해결합니다.

### 2. 명확한 의존성 규칙

FSD는 레이어 간 명확한 의존성 규칙을 제공합니다:

- **하향식 의존성만 허용**: 상위 레이어는 하위 레이어에만 의존할 수 있습니다.
- **수평적 의존성 금지**: 동일한 레이어 내 다른 슬라이스에 직접 의존할 수 없습니다.

**기존 문제 해결**: 
- "의존성 관리 어려움"과 "의존성 방향 불명확" 문제는 명확한 의존성 규칙을 통해 해결합니다.
- 순환 참조 문제는 하향식 의존성만 허용함으로써 원천적으로 방지합니다.

### 3. 기능 중심 조직

FSD는 비즈니스 기능을 중심으로 코드를 조직화합니다:

```markdown
features/
├── auth/
│   ├── ui/
│   ├── model/
│   └── api/
└── product-search/
    ├── ui/
    ├── model/
    └── api/
```

**기존 문제 해결**: 
- "관련 코드 분산" 문제를 하나의 기능에 관련된 모든 코드를 동일한 슬라이스에 위치시켜 해결합니다.
- "도메인 간 공유 필요 코드"는 더 낮은 레이어(entities, shared)에 배치하여 재사용성 문제를 해결합니다.

### 4. Public API를 통한 캡슐화

FSD는 각 슬라이스의 Public API를 통해 내부 구현을 캡슐화합니다:

```javascript
// features/auth/index.js (Public API)
export { LoginForm } from './ui/LoginForm';
export { registerUser } from './model/registration';
// 내부 구현은 외부에 노출되지 않음
```

**기존 문제 해결**: 
- 슬라이스 내부 구현 변경이 외부에 영향을 미치지 않도록 하여 유지보수성을 향상시킵니다.
- 명확한 사용 계약을 제공하여 다른 개발자가 모듈의 목적과 사용법을 쉽게 이해할 수 있게 합니다.

## 실무에서의 FSD 점진적 도입 방법 {/* toc-title: 점진적 도입 방법 */}

FSD는 이상적인 아키텍처 패턴이지만, 실무에서는 기존 프로젝트에 한 번에 전체 구조를 적용하기 어려울 수 있습니다. 다음은 FSD를 점진적으로 도입하는 효과적인 방법입니다:

### 1. 기능 단위의 점진적 마이그레이션

모든 코드를 한 번에 FSD로 변환하려고 시도하지 마세요. 대신, 다음과 같이 진행하세요:

1. 새로운 기능부터 FSD 구조로 개발하기 시작합니다.
2. 기존 기능은 수정이 필요할 때 점진적으로 FSD 구조로 리팩토링합니다.
3. 우선순위가 낮은 레거시 코드는 당장 변경하지 않고 그대로 유지합니다.

### 2. 모든 레이어를 한 번에 도입할 필요 없음

FSD의 6개 레이어를 모두 한 번에 도입할 필요는 없습니다:

1. 초기에는 `pages`, `features`, `shared` 레이어만 사용하는 단순화된 버전으로 시작할 수 있습니다.
2. 애플리케이션이 성장함에 따라 필요한 경우 `widgets`, `entities` 레이어를 추가합니다.
3. `app` 레이어는 애플리케이션의 규모가 커질 때 도입을 고려합니다.

### 3. 레이어 내부 코드 배치의 유연성

실무에서는 항상 이상적인 코드 배치가 어려울 수 있습니다. FSD는 다음과 같은 유연성을 제공합니다:

1. **처음 사용되는 코드는 상위 레이어에 배치 가능**: 특정 기능이 한 페이지에서만 사용된다면, 처음에는 `pages` 레이어에 배치하고, 재사용이 필요해질 때 적절한 레이어(예: `features`)로 이동시킬 수 있습니다.

2. **점진적 추출**: 코드가 여러 곳에서 사용되기 시작하면, 그때 더 낮은 레이어로 추출하여 재사용성을 높입니다.

```markdown
pages/
├── product-page/
│   └── ProductReviews.tsx  // 처음에는 여기에 구현
└── profile-page/
    // 여기서도 리뷰 기능이 필요하다면?
    // → features/reviews로 추출하여 재사용
```

### 4. 실무 적용 팁

1. **팀의 합의**: FSD 도입 전에 팀원들과 충분히 논의하고 합의를 이끌어내세요.
2. **문서화**: 어떤 규칙을 따르고 있는지, 어떤 부분은 유연하게 적용할 것인지 문서화하세요.
3. **린터 설정**: 가능하다면 ESLint 등의 린터에 FSD 규칙을 설정하여 자동으로 의존성 규칙을 검사하세요.
4. **점진적 학습**: 팀원들이 FSD 개념을 점진적으로 학습할 수 있도록 시간을 주세요.

## 실제 적용 사례: 기존 코드와 FSD 코드의 비교 {/* toc-title: 실제 적용 사례 */}

### 인증 기능 구현 비교

**기존 기술 중심 구조:**
```markdown
components/
├── LoginForm.tsx
└── RegisterForm.tsx
services/
└── authService.ts
hooks/
└── useAuth.ts
utils/
└── authValidators.ts
```

이 구조에서는 인증 관련 코드가 여러 폴더에 분산되어 있어, 인증 기능을 이해하거나 수정하기 위해 여러 파일을 찾아야 합니다.

**FSD 적용 후:**
```markdown
features/
└── auth/
    ├── ui/
    │   ├── LoginForm.tsx
    │   └── RegisterForm.tsx
    ├── api/
    │   └── authApi.ts
    ├── model/
    │   └── useAuth.ts
    ├── lib/
    │   └── validators.ts
    └── index.ts  // Public API
```

모든 인증 관련 코드가 한 곳에 모여 있어 관련 기능을 쉽게 찾고 이해할 수 있습니다.

### 점진적 도입 예시

프로젝트 초기에는 다음과 같이 단순화된 구조로 시작할 수 있습니다:

```markdown
pages/
├── home/
├── profile/
└── product/
features/
├── auth/
└── cart/
shared/
├── ui/
├── api/
└── lib/
```

애플리케이션이 성장함에 따라 필요한 레이어를 추가하고 코드를 적절한 위치로 리팩토링합니다:

```markdown
app/
pages/
widgets/
├── header/
├── footer/
└── product-card/
features/
entities/
├── user/
└── product/
shared/
```

## 결론

Feature Sliced Design은 프론트엔드 애플리케이션의 복잡성을 관리하기 위한 체계적인 접근 방식을 제공합니다. 기존 아키텍처의 한계를 극복하면서도, 실무에서 점진적으로 도입할 수 있는 유연성을 제공합니다.

FSD의 핵심 가치는 다음과 같습니다:

1. **명확한 책임 분리**로 코드 탐색과 이해가 용이해집니다.
2. **엄격한 의존성 규칙**으로 결합도를 낮추고 유지보수성을 향상시킵니다.
3. **기능 중심 조직**으로 비즈니스 도메인의 가시성을 높이고 개발 효율성을 증가시킵니다.
4. **점진적 도입 가능성**으로 실무에서 현실적으로 적용할 수 있습니다.

FSD는 처음부터 완벽하게 모든 레이어와 규칙을 적용할 필요가 없습니다. 프로젝트와 팀의 상황에 맞게 점진적으로 도입하면서, 필요에 따라 코드를 적절한 위치로 이동시키는 유연한 접근 방식이 실무에서 더 효과적입니다.

프론트엔드 아키텍처를 설계하거나 개선할 때 Feature Sliced Design의 원칙을 고려한다면, 더 유지보수하기 쉽고 확장 가능한 코드베이스를 구축할 수 있을 것입니다.
